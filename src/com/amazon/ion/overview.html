<!-- Copyright (c) 2007-2011 Amazon.com, Inc.  All rights reserved. -->
<html>
<body>
IonJava is the reference implementation of the
<a href="http://w.amazon.com/?Ion">Ion data notation</a> for the
Java<sup><font size="-4">TM</font></sup> 2 Platform Standard Edition 5.0
and above.
<p>
This document describes all classes intended for public consumption, limited to
the packages listed here.  The distribution includes other implementation
packages not documented here (<em>e.g.</em> {@code com.amazon.ion.impl});
your use of those packages is not supported, so do us both a favor and
<b>don't use them!</b>
<p>
More generally:
<b>Any behavior or features not present in this API documentation is
unsupported, probably untested, and subject to change without notice.</b>

<h1>Start at IonSystem</h1>

The central interface in IonJava is {@link com.amazon.ion.IonSystem}, which is
the main factory and facade for all Ion processing.
The intended architectural pattern is for your application to build a
single system instance and use it
throughout the application.  The {@code IonSystem} interface provides access
to all other components, including the capability to construct
{@link com.amazon.ion.IonValue IonValue} hierarchies.
<p>
This all means your first task is acquiring a system instance, and for that we
turn to {@link com.amazon.ion.system.IonSystemBuilder IonSystemBuilder}.
Here's the easiest way to bootstrap:
<pre>
    IonSystem ion = IonSystemBuilder.standard().build();
</pre>
That should be sufficient for many, but not all, applications.  Long-running
services will probably want to use a non-default 
{@linkplain com.amazon.ion.IonCatalog catalog} by configuring the builder 
before calling {@link com.amazon.ion.system.IonSystemBuilder#build() build()}.

<h2>SystemFactory is Deprecated</h2>
As of early 2011, the {@link com.amazon.ion.system.SystemFactory SystemFactory}
class has been deprecated in favor of {@code IonSystemBuilder}.
This should be a straightforward application change and we strongly recommend
that all applications update.
<!--, but at the moment the 
builder behaves differently in that it produces systems using a different
{@link com.amazon.ion.IonValue IonValue} implementation.
<b>Read the documentation of
{@link com.amazon.ion.system.IonSystemBuilder IonSystemBuilder}
to determine if your application should change.</b>
-->

<h2>An Important Caveat</h2>
Objects
returned by one {@code IonSystem} cannot by mixed with objects returned by
another {@code IonSystem}!  For example, the following code is <b>not
guaranteed to work</b>:

<pre>
    IonSystem sys1 = IonSystemBuilder.standard().build();
    IonSystem sys2 = IonSystemBuilder.standard().build();
    
    IonList parent = sys1.newEmptyList();
    IonInt  child  = sys2.newInt(23);
    parent.add(child); // NOT SUPPORTED
</pre>

Given any {@code IonValue} instance it is possible to retrieve the relevant
system via {@link com.amazon.ion.IonValue#getSystem()}. 
This is generally the best way to ensure
that you're using the correct system while modifying existing trees.
You can also use the "Curried" insertion methods to add new values to
collections:
<pre>
    struct.put("f").newInt(3);
    list.add().newString("demo");
</pre>


<h1>Getting Data In</h1>

This release defines three mechanisms for accepting Ion data:
<ul>
  <li>{@link com.amazon.ion.IonReader IonReader} scans an input stream using a 
    "pull parsing" paradigm. This is a low-level, high-performance API, and
    the other mechanisms are built on top of it.
  <li>Iteration reads an input stream by
    iterating over its top-level elements.  This "one at a time" input
    mechanism is intended for stream-oriented applications.
  <li>{@link com.amazon.ion.IonLoader IonLoader} loads an entire input stream
    into a single {@linkplain com.amazon.ion.IonDatagram datagram}.
    This "all at once" input mechanism is intended for document-oriented
    applications.
</ul>

All mechanisms accept either text or binary Ion data, and applications should
rarely care about the input format.
<p>
To construct an {@code IonReader}, call one of the {@code newReader} methods
on {@code IonSystem}; for example 
{@link com.amazon.ion.IonSystem#newReader(InputStream)}. 
You can then pull data from the reader. Don't forget to 
{@link com.amazon.ion.IonReader#close() close} it when you're done!
<p>
Ion iterators are extensions of
{@link java.util.Iterator} so they are used once and then discarded.
Use the various {@code iterate} methods on {@code IonSystem} to
create them; for example 
{@link com.amazon.ion.IonSystem#iterate(InputStream)}. 
<p>
To construct an {@code IonLoader}, call
{@link com.amazon.ion.IonSystem#newLoader()} and configure it as necessary.
You can reuse a loader many times, even from multiple threads.  The system
factory also maintains a "default loader" so you don't have to pass one around,
see {@link com.amazon.ion.IonSystem#getLoader()}.

<h1>Getting Data Out</h1>

There's also several mechanisms for generating Ion data:
<ul>
  <li>{@link com.amazon.ion.IonWriter IonWriter} is the low-level API for
    generating Ion data in some form. It's agnostic to the output format; in
    theory the actual output could be some other format entirely.
  <li>{@link com.amazon.ion.util.Printer Printer} is the most flexible way to 
    create Ion text data from an {@link com.amazon.ion.IonValue IonValue}.
  <li>{@link com.amazon.ion.IonValue#toString() IonValue.toString()} will also
    generate Ion text, but it's primarily intended for debugging purposes and
    cannot be customized.  It's format is not guaranteed so don't assume that
    it will always output the same thing!
  <li>{@link com.amazon.ion.IonValue#writeTo(IonWriter)} outputs Ion data in
    the writer's format. This is the best way to output the data model.
  <li>From an {@link com.amazon.ion.IonDatagram IonDatagram} you can call
    {@link com.amazon.ion.IonDatagram#getBytes() getBytes()} to get Ion
    binary data.
</ul>

You can create {@code IonWriter}s using methods on {@code IonSystem}, but the
{@link com.amazon.ion.system.IonTextWriterBuilder} provides more flexibility.

</body>
</html>
