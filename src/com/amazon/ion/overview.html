<!-- Copyright (c) 2007-2009 Amazon.com, Inc.  All rights reserved. -->
<html>
<body>
IonJava is the reference implementation of the
<a href="http://w.amazon.com/?Ion">Ion data notation</a> for the
Java<sup><font size="-4">TM</font></sup> 2 Platform Standard Edition 5.0
and above.
<p>
This document describes all classes intended for public consumption, limited to
the packages {@link com.amazon.ion}, {@link com.amazon.ion.system}, and
{@link com.amazon.ion.util}.  The distribution includes other implementation
packages not documented here (<em>e.g.</em> {@code com.amazon.ion.impl});
your use of those packages is not supported, so do us both a favor and
<b>don't use them!</b>


<h1>Start at IonSystem</h1>

The central interface in IonJava is {@link com.amazon.ion.IonSystem}, which is
the main factory and facade for all Ion processing.
The intended architectural pattern is for your application to acquire a
single system instance from the 
{@link com.amazon.ion.system.SystemFactory SystemFactory} and use it
throughout the application.  The {@code IonSystem} interface provides access
to all other components, including the capability to construct
{@link com.amazon.ion.IonValue IonValue} hierarchies.  Note that objects
returned by one {@code IonSystem} cannot by mixed with objects returned by
another {@code IonSystem}!  For example, the following code is <b>not
guaranteed to work</b>:

<pre>
    IonSystem sys1 = SystemFactory.newSystem();
    IonSystem sys2 = SystemFactory.newSystem();
    
    IonList parent = sys1.newEmptyList();
    IonInt  child  = sys2.newInt(23);
    parent.add(child); // NOT SUPPORTED
</pre>

Given any {@code IonValue} instance it is possible to retrieve the relevant
system via {@link com.amazon.ion.IonValue#getSystem()}. 
This is generally the best way ensure
that you're using the correct system while modifying existing trees.
You can also use the "Curried" insertion methods to add new values to
collections:
<pre>
    struct.put("f").newInt(3);
    list.add().newString("demo");
</pre>


<h1>Getting Data In</h1>

This release defines three mechanisms for accepting Ion data:
<ul>
  <li>{@link com.amazon.ion.IonLoader IonLoader} loads an entire input stream
    into a single {@linkplain com.amazon.ion.IonDatagram datagram}.
    This "all at once" input mechanism is intended for document-oriented
    applications.
  </li>
  <li>Iteration reads an input stream by
    iterating over its top-level elements.  This "one at a time" input
    mechanism is intended for stream-oriented applications.
  </li>
  <li>{@link com.amazon.ion.IonReader IonReader} scans an input stream using a 
    "pull parsing" paradigm. 
</ul>

All mechanisms accept either text or binary Ion data, and applications should
rarely care about the input format.
<p>
To construct an {@code IonLoader}, call
{@link com.amazon.ion.IonSystem#newLoader()} and configure it as necessary.
You can reuse a loader many times, even from multiple threads.  The system
factory also maintains a "default loader" so you don't have to pass one around,
see {@link com.amazon.ion.IonSystem#getLoader()}.
<p>
In contrast, iterators are not reusable: they are extensions of
{@link java.util.Iterator} so they are used once and then discarded.
Use the various {@code iterate()} factory methods on {@code IonSystem} to
create iterators.
<p>
To construct an {@code IonReader}, call one of the {@code newReader} methods
on {@code IonSystem}; for example 
{@link com.amazon.ion.IonSystem#newReader(String)}. 
You can then pull data from the input source.
</body>
</html>
